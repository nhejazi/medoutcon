utils::globalVariables(c("..eif_component_names"))

#' One-step estimator: mediation parameter under mediator-outcome confounding
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param contrast ...
#' @param g_lrnr_stack A \code{Stack} object, or other learner class (inheriting from
#'  \code{Lrnr_base}), containing a single or set of instantiated learners from
#'  the \code{sl3} package, to be used in fitting a model for the propensity
#'  score, i.e., g = P(A | W).
#' @param e_lrnr_stack A \code{Stack} object, or other learner class (inheriting from
#'  \code{Lrnr_base}), containing a single or set of instantiated learners from
#'  the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | Z, W).
#' @param m_lrnr_stack A \code{Stack} object, or other learner class (inheriting from
#'  \code{Lrnr_base}), containing a single or set of instantiated learners from
#'  the \code{sl3} package, to be used in fitting the outcome regression.
#' @param q_lrnr_stack A \code{Stack} object, or other learner class (inheriting from
#'  \code{Lrnr_base}), containing a single or set of instantiated learners from
#'  the \code{sl3} package, to be used in fitting a regression involving the
#'  mediator-outcome confounder, i.e., q(L | A', W).
#' @param r_lrnr_stack A \code{Stack} object, or other learner class (inheriting from
#'  \code{Lrnr_base}), containing a single or set of instantiated learners from
#'  the \code{sl3} package, to be used in fitting a regression involving the
#'  mediator-outcome confounder, i.e., r(L | A', M, W).
#' @param u_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e., u(L, A, W) =
#'  E[m(A, L, Z, W) * (q(L|A,W) / r(L|A,Z,W)) * (e(a'|Z,W) / e(A|Z,W)) |
#'  L = l, A = a, W = w].
#' @param v_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e., v(A,W) =
#'  E[\int_z m(a', l, Z, W) * q(l|A',W) d\nu(z) | A = a, W = w)].
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param cv_folds A \code{numeric} integer value specifying the number of folds
#'  to be created for cross-validation. Use of cross-validation / cross-fitting
#'  allows for entropy conditions on the AIPW estimator to be relaxed. Note: for
#'  compatibility with \code{origami::make_folds}, this value specified here
#'  must be greater than or equal to 2; the default is to create 10 folds.
#'
#' @importFrom stats var
#' @importFrom origami make_folds cross_validate folds_vfold
#'
est_onestep <- function(data,
                        contrast,
                        g_lrnr_stack,
                        e_lrnr_stack,
                        m_lrnr_stack,
                        q_lrnr_stack,
                        r_lrnr_stack,
                        u_lrnr_stack,
                        v_lrnr_stack,
                        w_names,
                        m_names,
                        cv_folds = 10) {
  # create folds for use with origami::cross_validate
  folds <- origami::make_folds(data,
    fold_fun = origami::folds_vfold,
    V = cv_folds
  )

  # perform the cv_eif procedure on a per-fold basis
  cv_eif_results <- origami::cross_validate(
    cv_fun = cv_eif,
    folds = folds,
    data = data,
    delta = delta,
    shift_type = shift_type,
    lrnr_stack_g = g_lrnr_stack,
    lrnr_stack_e = e_lrnr_stack,
    lrnr_stack_m = m_lrnr_stack,
    lrnr_stack_phi = phi_lrnr_stack,
    w_names = w_names,
    z_names = z_names,
    use_future = FALSE,
    .combine = FALSE
  )

  # combine results of EIF components for full EIF
  D_obs <- lapply(cv_eif_results[[1]], function(x) {
    D_obs_fold <- rowSums(x[, ..eif_component_names])
    return(D_obs_fold)
  })

  # get estimated observation-level values of EIF
  estim_eif <- do.call(c, D_obs)

  # compute one-step estimate of parameter and variance from EIF
  estim_onestep_param <- mean(estim_eif)
  estim_onestep_var <- stats::var(estim_eif) / length(estim_eif)

  # output
  estim_onestep_out <- list(
    theta = estim_onestep_param,
    var = estim_onestep_var,
    eif = (estim_eif - estim_onestep_param),
    type = "onestep"
  )
  return(estim_onestep_out)
}

################################################################################

#' EIF for (in)direct effect under mediator-outcome confounding
#'
#' @param fold Object specifying cross-validation folds as generated by a call
#'  to \code{origami::make_folds}.
#' @param data_ing A \code{data.table} containing the observed data with columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param g_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, for use in fitting a model for the propensity
#'  score, i.e., g = P(A | W).
#' @param e_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | Z, W).
#' @param m_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression.
#' @param q_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a regression involving
#'  the mediator-outcome confounder, i.e., q(Z | A, W).
#' @param r_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a regression involving
#'  the mediator-outcome confounder, i.e., r(Z | A, M, W).
#' @param u_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  appearing in the efficient influence function, i.e., u(L, A, W) =
#'  E[m(A, Z, M, W) * (q(Z|A,W) / r(Z|A,M,W)) * (e(a'|M,W) / e(A|M,W)) |
#'  Z = z, A = a, W = w].
#' @param v_lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e., v(A,W) =
#'  E[\int_z m(a', z, M, W) * q(z | A', W) d\nu(z) | A = a, W = w)].
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table data.table
#' @importFrom origami training validation fold_index
#'
#' @keywords internal
#
cv_eif <- function(fold,
                   data_in,
                   contrast,
                   g_lrnr_stack,
                   e_lrnr_stack,
                   m_lrnr_stack,
                   q_lrnr_stack,
                   r_lrnr_stack,
                   u_lrnr_stack,
                   v_lrnr_stack,
                   w_names,
                   m_names) {
  # make training and validation data
  train_data <- origami::training(data_in, fold = folds[[1]])
  valid_data <- origami::validation(data_in, fold = folds[[1]])

  # 1) fit regression for propensity score regression
  g_out <- fit_g_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    lrnr_stack = g_lrnr_stack,
    w_names = w_names
  )

  # 2) fit clever regression for treatment, conditional on mediators
  e_out <- fit_e_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    lrnr_stack = e_lrnr_stack,
    m_names = m_names,
    w_names = w_names
  )

  # 3) fit outcome regression
  m_out <- fit_m_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    lrnr_stack = m_lrnr_stack,
    m_names = m_names,
    w_names = w_names
  )

  # 4) fit mediator-outcome confounder regression, excluding mediator(s)
  q_out <- fit_moc_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    lrnr_stack = q_lrnr_stack,
    m_names = m_names,
    w_names = w_names,
    type = "q"
  )

  # 5) fit mediator-outcome confounder regression, conditioning on mediator(s)
  r_out <- fit_moc_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    lrnr_stack = r_lrnr_stack,
    m_names = m_names,
    w_names = w_names,
    type = "r"
  )

  # 6) construct pseudo-outcome and perform regression for nuisance parameter u
  u_pseudo_train <- m_out$m_est_train$m_pred_A_natural *
    (q_out$moc_est_train$moc_pred_A_natural /
     r_out$moc_est_train$moc_pred_A_natural) *
    (e_out$e_est_train$e_pred_A_star / e_out$e_est_train$e_pred_A_natural)
  ## construct data set and training task
  u_data_train <- data.table::as.data.table(cbind(train_data[, ..w_names],
                                                  train_data$A, train_data$Z,
                                                  u_pseudo_train))
  data.table::setnames(u_data_train, c(w_names, "A", "Z", "U_pseudo"))
  u_task_train <- sl3::sl3_Task$new(
    data = u_data_train,
    covariates = c(w_names, "A", "Z"),
    outcome_type = "continuous",
    outcome = "U_pseudo"
  )
  ## fit model for nuisance parameter regression on training data
  u_param_fit <- u_lrnr_stack$train(u_task_train)

  ## now, same process but for the validation set
  u_pseudo_valid <- m_out$m_est_valid$m_pred_A_natural *
    (q_out$moc_est_valid$moc_pred_A_natural /
     r_out$moc_est_valid$moc_pred_A_natural) *
    (e_out$e_est_valid$e_pred_A_star / e_out$e_est_valid$e_pred_A_natural)
  ## construct data set and validation task for prediction
  u_data_valid <- data.table::as.data.table(cbind(valid_data[, ..w_names],
                                                  valid_data$A, valid_data$Z,
                                                  u_pseudo_valid))
  data.table::setnames(u_data_valid, c(w_names, "A", "Z", "U_pseudo"))
  u_task_valid <- sl3::sl3_Task$new(
    data = u_data_valid,
    covariates = c(w_names, "A", "Z"),
    outcome_type = "continuous",
    outcome = "U_pseudo"
  )
  ## predict from nuisance parameter regression model on validation data
  u_valid_pred <- u_param_fit$predict(u_task_valid)

  # 7) construct pseudo-outcome and perform regression for nuisance parameter v
  ## first, compute components of integral over mediation-outcome confounder
  v_pseudo <- lapply(as.list(unique(train_data$Z)), function(mediator_val) {
    # training data
    train_data_z_interv <- data.table::copy(train_data)
    train_data_z_interv[, Z := mediator_val]
    train_data_z_interv[, A := contrast[1]]

    # tasks for predicting from trained m and q regression models
    m_reg_train_v_subtask <- sl3::sl3_Task$new(
      data = train_data_z_interv,
      covariates = c(w_names, "A", "Z", m_names),
      outcome = "Y"
    )
    q_reg_train_v_subtask <- sl3::sl3_Task$new(
      data = train_data_z_interv,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # outcome regression after intervening on mediator-outcome confounder
    m_pred_train_z_interv <- m_out$m_fit$predict(m_reg_train_v_subtask)

    # "q" nuisance regression after intervening on mediator-outcome confounder
    q_pred_train_z_interv <- q_out$moc_fit$predict(q_reg_train_v_subtask)

    # now on validation set
    valid_data_z_interv <- data.table::copy(valid_data)
    valid_data_z_interv[, Z := mediator_val]
    valid_data_z_interv[, A := contrast[1]]

    # tasks for predicting from trained m and q regression models
    m_reg_valid_v_subtask <- sl3::sl3_Task$new(
      data = valid_data_z_interv,
      covariates = c(w_names, "A", "Z", m_names),
      outcome = "Y"
    )
    q_reg_valid_v_subtask <- sl3::sl3_Task$new(
      data = valid_data_z_interv,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # outcome regression after intervening on mediator-outcome confounder
    m_pred_valid_z_interv <- m_out$m_fit$predict(m_reg_valid_v_subtask)

    # "q" nuisance regression after intervening on mediator-outcome confounder
    q_pred_valid_z_interv <- q_out$moc_fit$predict(q_reg_valid_v_subtask)

    # return partial pseudo-outcome for v nuisance regression
    out_train <- m_pred_train_z_interv * q_pred_train_z_interv
    out_valid <- m_pred_valid_z_interv * q_pred_valid_z_interv
    out <- list(training = out_train, validation = out_valid)
    return(out)
  })
  ## compute pseudo-outcome and build regression task for training set
  v_pseudo_train <- v_pseudo[[1]]$training + v_pseudo[[2]]$training
  v_data_train <- data.table::as.data.table(cbind(train_data[, ..w_names],
                                                  train_data$A, v_pseudo_train))
  data.table::setnames(v_data_train, c(w_names, "A", "V_pseudo"))
  v_task_train <- sl3::sl3_Task$new(
    data = v_data_train,
    covariates = c(w_names, "A"),
    outcome_type = "continuous",
    outcome = "V_pseudo"
  )
  ## compute pseudo-outcome and build regression task for validation set
  v_pseudo_valid <- v_pseudo[[1]]$validation + v_pseudo[[2]]$validation
  v_data_valid <- data.table::as.data.table(cbind(valid_data[, ..w_names],
                                                  valid_data$A, v_pseudo_valid))
  data.table::setnames(v_data_valid, c(w_names, "A", "V_pseudo"))
  v_task_valid <- sl3::sl3_Task$new(
    data = v_data_valid,
    covariates = c(w_names, "A"),
    outcome_type = "continuous",
    outcome = "V_pseudo"
  )
  ## fit regression model for v on training task, get predictions on validation
  v_param_fit <- v_lrnr_stack$train(v_task_train)
  v_valid_pred <- v_param_fit$predict(v_task_valid)




  # compute component Dzw from nuisance parameters
  Dzw_est <- compute_Dzw(g_output = g_out, m_output = m_out,
                         shift_type = shift_type)
  Dzw <- rep(as.numeric(sum(Dzw_est$dzw)), times = nrow(g_out$g_est))

  # compute component Da from nuisance parameters
  g_natural <- g_out$g_est$g_natural
  a_natural <- g_out$a_vals$a_natural

  # approximate Monte Carlo integral using inverse uniform weighting
  int_Da_phi <- integrate_over_g(g_mech = g_natural,
                                 a_vals = a_natural,
                                 weighting = phi_est)
  Da <- phi_est - sum(int_Da_phi)

  # compute component Dy from nuisance parameters
  ipw_out <- compute_ipw(
    g_output = g_out, e_output = e_out,
    shift_type = shift_type
  )

  # stabilize weights in AIPW by dividing by sample average since E[g/e] = 1
  mean_ipw <- ipw_out$mean_ipw
  g_shifted <- ipw_out$g_shifted
  e_pred <- ipw_out$e_pred
  sipw <- ((g_shifted / e_pred) / mean_ipw)

  # extract outcome mechanism estimate under natural intervention value
  m_pred <- m_out$m_pred$m_natural

  # assemble Dy component estimate
  Dy <- sipw * (valid_data$Y - m_pred)

  # output list
  out <- list(data.table::data.table(
    Dy = Dy, Da = Da, Dzw = Dzw,
    fold = origami::fold_index()
  ))
  return(out)
}
