utils::globalVariables(c("..w_names", "A", "Z"))

#' One-step estimator: mediation parameter under mediator-outcome confounding
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{\link{medoutcon}}.
#' @param contrast ...
#' @param g_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, for use in fitting a model for the propensity
#'  score, i.e., \eqn{g = P(A | W)}.
#' @param e_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., \eqn{e = P(A | Z, W)}.
#' @param m_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression.
#' @param q_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, for use in fitting a regression involving the
#'  mediator-outcome confounder, i.e., \eqn{q(L | A', W)}.
#' @param r_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a regression involving
#'  the mediator-outcome confounder, i.e., \eqn{r(L | A', M, W)}.
#' @param u_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e.,
#'  \eqn{u(L, A, W) = E[m(A, L, Z, W) * (q(L|A,W) / r(L|A,Z,W)) *
#'  (e(a'|Z,W) / e(A|Z,W)) | L = l, A = a, W = w]}.
#' @param v_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e.,
#'  \eqn{v(A,W) = E[\int_z m(a', l, Z, W) * q(l|A',W) d\nu(z) | A = a, W = w)]}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function
#'  \code{\link{medoutcon}}.
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{\link{medoutcon}}.
#' @param cv_folds A \code{numeric} integer value specifying the number of folds
#'  to be created for cross-validation. Use of cross-validation / cross-fitting
#'  allows for entropy conditions on the one-step estimator to be relaxed. Note:
#'  for compatibility with \code{origami::make_folds}, this value specified here
#'  must be greater than or equal to 2; the default is to create 10 folds.
#'
#' @importFrom stats var
#' @importFrom origami make_folds cross_validate folds_vfold
#'
est_onestep <- function(data,
                        contrast,
                        g_learners,
                        e_learners,
                        m_learners,
                        q_learners,
                        r_learners,
                        u_learners,
                        v_learners,
                        w_names,
                        m_names,
                        cv_folds = 10) {
  # create folds for use with origami::cross_validate
  folds <- origami::make_folds(data,
    fold_fun = origami::folds_vfold,
    V = cv_folds
  )

  # perform the cv_eif procedure on a per-fold basis
  cv_eif_results <- origami::cross_validate(
    cv_fun = cv_eif,
    folds = folds,
    data_in = data,
    contrast = contrast,
    g_learners = g_learners,
    e_learners = e_learners,
    m_learners = m_learners,
    q_learners = q_learners,
    r_learners = r_learners,
    u_learners = u_learners,
    v_learners = v_learners,
    w_names = w_names,
    m_names = m_names,
    use_future = FALSE,
    .combine = FALSE
  )

  # get estimated observation-level values of efficient influence function
  eif_est <- do.call(c, lapply(cv_eif_results[[1]], `[[`, 1))

  # compute one-step estimate and variance from efficient influence function
  os_est <- mean(eif_est)
  os_var <- stats::var(eif_est) / length(eif_est)

  # output
  os_est_out <- list(
    theta = os_est,
    var = os_var,
    eif = (eif_est - os_est),
    type = "onestep"
  )
  return(os_est_out)
}

################################################################################

#' EIF for stochastic (in)direct effects under mediator-outcome confounding
#'
#' @param fold Object specifying cross-validation folds as generated by a call
#'  to \code{origami::make_folds}.
#' @param data_ing A \code{data.table} containing the observed data with columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{\link{medoutcon}}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param g_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, for use in fitting a model for the propensity
#'  score, i.e., \eqn{g = P(A | W)}.
#' @param e_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., \eqn{e = P(A | Z, W)}.
#' @param m_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression.
#' @param q_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a regression involving
#'  the mediator-outcome confounder, i.e., \eqn{q(Z | A, W)}.
#' @param r_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a regression involving
#'  the mediator-outcome confounder, i.e., \eqn{r(Z | A, M, W)}.
#' @param u_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  appearing in the efficient influence function, i.e.,
#'  \eqn{u(L, A, W) = E[m(A, Z, M, W) * (q(Z|A,W) / r(Z|A,M,W)) * (e(a'|M,W) /
#'  e(A|M,W)) | Z = z, A = a, W = w]}.
#' @param v_learners A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a reduced regression
#'  useful for computing the efficient one-step estimator, i.e.,
#'  \eqn{v(A,W) = E[\int_z m(a', z, M, W) * q(z | A', W) d\nu(z) | A = a,
#'  W = w)]}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function
#'  \code{\link{medoutcon}}.
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{\link{medoutcon}}.
#'
#' @importFrom data.table data.table copy
#' @importFrom origami training validation fold_index
#'
#' @keywords internal
#
cv_eif <- function(fold,
                   data_in,
                   contrast,
                   g_learners,
                   e_learners,
                   m_learners,
                   q_learners,
                   r_learners,
                   u_learners,
                   v_learners,
                   w_names,
                   m_names) {
  # make training and validation data
  train_data <- origami::training(data_in)
  valid_data <- origami::validation(data_in)

  # 1) fit regression for propensity score regression
  g_out <- fit_treat_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    learners = g_learners,
    w_names = w_names,
    m_names = m_names,
    type = "g"
  )

  # 2) fit clever regression for treatment, conditional on mediators
  e_out <- fit_treat_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    learners = e_learners,
    w_names = w_names,
    m_names = m_names,
    type = "e"
  )

  # 3) fit outcome regression
  m_out <- fit_m_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    learners = m_learners,
    m_names = m_names,
    w_names = w_names
  )

  # 4) fit mediator-outcome confounder regression, excluding mediator(s)
  q_out <- fit_moc_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    learners = q_learners,
    m_names = m_names,
    w_names = w_names,
    type = "q"
  )

  # 5) fit mediator-outcome confounder regression, conditioning on mediator(s)
  r_out <- fit_moc_mech(
    train_data = train_data,
    valid_data = valid_data,
    contrast = contrast,
    learners = r_learners,
    m_names = m_names,
    w_names = w_names,
    type = "r"
  )

  # extract components and re-name for ease of generating influence function
  # NOTE: we only do this for observations in the validation set
  m_prime <- m_out$m_est_valid$m_pred_A_prime
  e_star <- e_out$treat_est_valid$treat_pred_A_star
  g_star <- g_out$treat_est_valid$treat_pred_A_star
  e_prime <- e_out$treat_est_valid$treat_pred_A_prime
  g_prime <- g_out$treat_est_valid$treat_pred_A_prime
  q_prime_Z_one <- q_out$moc_est_valid_Z_one$moc_pred_A_prime
  r_prime_Z_one <- r_out$moc_est_valid_Z_one$moc_pred_A_prime
  q_prime_Z_natural <- q_out$moc_est_valid_Z_natural$moc_pred_A_prime
  r_prime_Z_natural <- r_out$moc_est_valid_Z_natural$moc_pred_A_prime

  # need pseudo-outcome regressions with intervention set to a contrast
  # NOTE: training fits of these nuisance functions must be performed using the
  #       data corresponding to the natural intervention value but predictions
  #       are only needed for u(z,a',w) and v(a*,w) as per the EIF
  valid_data_a_prime <- data.table::copy(valid_data)[, A := contrast[1]]
  valid_data_a_star <- data.table::copy(valid_data)[, A := contrast[2]]
  u_out <- fit_nuisance_u(
    train_data = train_data,
    valid_data = valid_data_a_prime,
    learners = u_learners,
    m_out = m_out,
    g_out = g_out,
    q_out = q_out,
    r_out = r_out,
    e_out = e_out,
    w_names = w_names
  )
  u_prime <- u_out$u_pred

  v_out <- fit_nuisance_v(
    train_data = train_data,
    valid_data = valid_data_a_star,
    contrast = contrast,
    learners = v_learners,
    m_out = m_out,
    q_out = q_out,
    m_names = m_names,
    w_names = w_names
  )
  v_star <- v_out$v_pred

  # need an integral involving U over mediator-outcome confounder Z
  # assuming Z in {0,1}, other cases not supported yet
  u_int_eif <- lapply(c(0, 1), function(z_val) {
    # intervene on training and validation data sets
    valid_data_z_interv <- data.table::copy(valid_data)
    valid_data_z_interv[, `:=`(
      Z = z_val,
      A = contrast[1],
      U_pseudo = u_prime
    )]

    # predict u(z, a', w) using intervened data with treatment set A = a'
    u_task_valid_z_interv <- sl3::sl3_Task$new(
      data = valid_data_z_interv,
      covariates = c("Z", "A", w_names),
      outcome = "U_pseudo",
      outcome_type = "continuous"
    )
    u_prime_z_interv <- u_out[["u_fit"]]$predict(u_task_valid_z_interv)

    q_pred_valid_z_val <- (z_val * q_prime_Z_one) +
      (1 - z_val) * (1 - q_prime_Z_one)

    # return partial pseudo-outcome for v nuisance regression
    out_valid <- u_prime_z_interv * q_pred_valid_z_val
    return(out_valid)
  })
  u_int_eif <- do.call(`+`, u_int_eif)

  # create inverse probability weights
  ipw_a_prime <- as.numeric(valid_data$A == contrast[1]) / g_prime
  ipw_a_star  <- as.numeric(valid_data$A == contrast[2]) / g_star

  h_star <- g_prime / g_star * q_prime_Z_natural / r_prime_Z_natural *
    e_star / e_prime

  # compute uncentered efficient influence function
  eif_y <- ipw_a_prime * h_star / mean(ipw_a_prime * h_star) * (valid_data$Y - m_prime)
  eif_u <- ipw_a_prime / mean(ipw_a_prime) * (u_prime - u_int_eif)
  eif_v <- ipw_a_star / mean(ipw_a_star) * (v_out$v_pseudo - v_star)

  eif <- eif_y + eif_u + eif_v + v_star

  # output list
  out <- list(data.table::data.table(
    D_star = eif, fold = origami::fold_index()
  ))
  return(out)
}
