#' Fit propensity score for treatment contrasts
#'
#' @param train_data A \code{data.table} containing the observed data; columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{train_data}, to be used for
#'  estimation via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention "A" to be compared. The default value of \code{c(0, 1)} assumes
#'  binary intervention node "A", though support for categorical interventions
#'  is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a propensity score model,
#'  i.e., g = P(A = 1 | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_g_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       w_names) {
  # construct task for propensity score fit
  g_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = w_names,
    outcome = "A"
  )

  # fit propensity score model with natural (observed) intervention values
  # NOTE: never need the non-intervened propensity score, so don't predict...
  g_natural_fit <- lrnr_stack$train(g_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # set intervention column to the first contrast
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # set intervention to first contrast a_prime := contrast[1]
    g_intervened_task <- sl3_Task$new(
      data = train_data_intervene,
      covariates = w_names,
      outcome_type = "binomial",
      outcome = "A"
    )

    # get predictions from natural propensity score model for intervened data
    g_intervened_pred_A_prime <- g_natural_fit$predict(g_intervened_task)

    # compute A = a_star = contrast[2] case by symmetry
    g_intervened_pred_A_star <- 1 - g_intervened_pred_A_prime

    # bounding to numerical precision and for positivity considerations
    out_g_mat <- cbind(g_intervened_pred_A_prime,
                       g_intervened_pred_A_star)
    out_g_est <- apply(out_g_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_g_est <- data.table::as.data.table(out_g_est)
    data.table::setnames(out_g_est, c("g_pred_A_prime", "g_pred_A_star"))

    # output
    out <- list(
      g_est = out_g_est,
      g_fit = g_natural_fit
    )
  } else {
    # set intervention columns to first contrast for training/validation splits
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]
    valid_data_intervene <- data.table::copy(valid_data)
    valid_data_intervene[, A := contrast[1]]

    # set intervention to first contrast a_prime := contrast[1]
    out_g_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # create task to generate contrast-specific predictions
      g_intervened_task <- sl3_Task$new(
        data = data_intervene,
        covariates = w_names,
        outcome_type = "binomial",
        outcome = "A"
      )

      # get predictions from natural propensity score model for intervened data
      g_intervened_pred_A_prime <- g_natural_fit$predict(g_intervened_task)

      # compute A = a_star = contrast[2] case by symmetry
      g_intervened_pred_A_star <- 1 - g_intervened_pred_A_prime

      # bounding to numerical precision and for positivity considerations
      out_g_mat <- cbind(g_intervened_pred_A_prime,
                         g_intervened_pred_A_star)
      out_g_est <- apply(out_g_mat, 2, function(x) {
                           x_precise <- bound_precision(x)
                           x_bounded <- bound_propensity(x_precise)
                           return(x_bounded)
                        })
      out_g_est <- data.table::as.data.table(out_g_est)
      data.table::setnames(out_g_est, c("g_pred_A_prime", "g_pred_A_star"))
    })

    # output
    out <- list(
      g_est_train = out_g_est[[1]],
      g_est_valid = out_g_est[[2]],
      g_fit = g_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit propensity score conditioning on mediators over given contrasts
#'
#' @param train_data A \code{data.table} containing the observed data; columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | M, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_e_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  # construct task for nuisance parameter fit
  e_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = c(m_names, w_names),
    outcome = "A"
  )

  # fit model on observed data
  e_natural_fit <- lrnr_stack$train(e_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    e_natural_pred <- e_natural_fit$predict()

    # create task for treatment-specific propensity score for first contrast
    e_intervened_task <- sl3_Task$new(
      data = train_data_intervene,
      covariates = c(m_names, w_names),
      outcome_type = "binomial",
      outcome = "A"
    )

    # predict from trained model on counterfactual data
    e_intervened_pred_A_prime <- e_natural_fit$predict(e_intervened_task)

    # get values of nuisance parameter E for A = a_star = contrast[2] by symmetry
    e_intervened_pred_A_star <- 1 - e_intervened_pred_A_prime

    # bounding to numerical precision and for positivity considerations
    out_e_mat <- cbind(e_natural_pred,
                       e_intervened_pred_A_prime,
                       e_intervened_pred_A_star)
    out_e_est <- apply(out_e_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_e_est <- data.table::as.data.table(out_e_est)
    data.table::setnames(out_e_est, c("e_pred_A_natural",
                                      "e_pred_A_prime",
                                      "e_pred_A_star"))

    # output
    out <- list(
      e_est = out_e_est,
      e_fit = e_natural_fit
    )
  } else {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]
    valid_data_intervene <- data.table::copy(valid_data)
    valid_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    e_natural_pred_train <- e_natural_fit$predict()
    e_natural_task_valid <- sl3::sl3_Task$new(
      data = valid_data,
      covariates = c(m_names, w_names),
      outcome = "A"
    )
    e_natural_pred_valid <- e_natural_fit$predict(e_natural_task_valid)

    # loop over training and validation data to get fold-specific predictions
    out_e_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # create task to generate predictions for contrast-specific predictions
      e_intervened_task <- sl3_Task$new(
        data = data_intervene,
        covariates = c(m_names, w_names),
        outcome_type = "binomial",
        outcome = "A"
      )

      # predict from trained model on counterfactual data
      e_intervened_pred_A_prime <- e_natural_fit$predict(e_intervened_task)

      # values of nuisance parameter E for A = a_star = contrast[2] by symmetry
      e_intervened_pred_A_star <- 1 - e_intervened_pred_A_prime

      # bounding to numerical precision and for positivity considerations
      out_e_mat <- cbind(e_intervened_pred_A_prime,
                         e_intervened_pred_A_star)
      out_e_est <- apply(out_e_mat, 2, function(x) {
                           x_precise <- bound_precision(x)
                           x_bounded <- bound_propensity(x_precise)
                           return(x_bounded)
                        })
      out_e_est <- data.table::as.data.table(out_e_est)
      return(out_e_est)
    })

    # add natural treatment estimates to post-intervention predictions
    out_e_est[[1]] <- cbind(e_natural_pred_train, out_e_est[[1]])
    out_e_est[[2]] <- cbind(e_natural_pred_valid, out_e_est[[2]])
    lapply(out_e_est, function(x) {
             data.table::setnames(x, c("e_pred_A_natural",
                                       "e_pred_A_prime",
                                       "e_pred_A_star"))
    })

    # output
    out <- list(
      e_est_train = out_e_est[[1]],
      e_est_valid = out_e_est[[2]],
      e_fit = e_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit outcome regression
#'
#' @param train_data A \code{data.table} containing the observed data, with
#'  columns in the order specified by the NPSEM (Y, M, Z, A, W), with column
#'  names set based on the original input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression,
#'  i.e., m(A, M, Z, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_m_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  #  construct task for propensity score fit
  m_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = c("A", m_names, "Z", w_names),
    outcome = "Y"
  )

  # fit and predict
  m_natural_fit <- lrnr_stack$train(m_natural_task)
  m_natural_pred <- m_natural_fit$predict()

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    m_natural_pred <- m_natural_fit$predict()

    # create task for post-intervention outcome regression
    m_intervened_prime_task <- sl3_Task$new(
      data = train_data_intervene,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )

    # predict from trained model on counterfactual data
    m_intervened_pred_A_prime <- m_natural_fit$predict(m_intervened_prime_task)

    # set intervention to second contrast a_star := contrast[2] and create task
    train_data_intervene[, A := contrast[2]]
    m_intervened_star_task <- sl3::sl3_Task$new(
      data = train_data_intervene,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )

    # predict from trained model on counterfactual data
    m_intervened_pred_A_star <- m_natural_fit$predict(m_intervened_star_task)

    # output
    out_m_est <- data.table::as.data.table(cbind(m_natural_pred,
                                                 m_intervened_pred_A_prime,
                                                 m_intervened_pred_A_star))
    data.table::setnames(out_m_est, c("m_pred_A_natural",
                                      "m_pred_A_prime",
                                      "m_pred_A_star"))

    # output
    out <- list(
      m_est = out_m_est,
      m_fit = m_natural_fit
    )
  } else {
    # copy both training and validation data, once for each contrast
    train_data_intervene <- data.table::copy(train_data)
    valid_data_intervene <- data.table::copy(valid_data)

    # predictions on observed data (i.e., under observed treatment status)
    m_natural_pred_train <- m_natural_fit$predict()
    m_natural_task_valid <- sl3::sl3_Task$new(
      data = valid_data,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )
    m_natural_pred_valid <- m_natural_fit$predict(m_natural_task_valid)

    # set intervention to first contrast a_prime := contrast[1]
    out_m_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # set intervention to first contrast a_prime := contrast[1]
      data_intervene[, A := contrast[1]]
      m_intervened_prime_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_prime <-
        m_natural_fit$predict(m_intervened_prime_task)

      # set intervention to first contrast a_star := contrast[2]
      data_intervene[, A := contrast[2]]
      m_intervened_star_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_star <- m_natural_fit$predict(m_intervened_star_task)

      # output
      out_m_est <- data.table::as.data.table(cbind(m_intervened_pred_A_prime,
                                                   m_intervened_pred_A_star))
      return(out_m_est)
    })

    # add natural treatment estimates to post-intervention predictions
    out_m_est[[1]] <- cbind(m_natural_pred_train, out_m_est[[1]])
    out_m_est[[2]] <- cbind(m_natural_pred_valid, out_m_est[[2]])
    lapply(out_m_est, function(x) {
             data.table::setnames(x, c("m_pred_A_natural",
                                       "m_pred_A_prime",
                                       "m_pred_A_star"))
    })

    # output
    out <- list(
      m_est_train = out_m_est[[1]],
      m_est_valid = out_m_est[[2]],
      m_fit = m_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit mediator-outcome confounder score with(out) conditioning on mediators
#'
#' @param train_data A \code{data.table} containing observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., q = E[z|a',W] and r = E[z|a',m,w]).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#' @param type A \code{character} vector indicating whether to condition on the
#'  mediators (M) or not. Specifically, this is an option for specifying one of
#'  two types of nuisance regressions: "r" is defined as the component that
#'  conditions on the mediators (i.e., r = E[z|a',m,w]) while "q" is defined as
#'  the component that does not (i.e., q = E[z|a',w]).
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_moc_mech <- function(train_data,
                         valid_data = NULL,
                         contrast,
                         lrnr_stack,
                         m_names,
                         w_names,
                         type = c("q", "r")) {
  # construct task for nuisance parameter fit
  if (type == "q") {
    moc_natural_task <- sl3::sl3_Task$new(
      data = train_data,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  } else if (type == "r") {
    moc_natural_task <- sl3::sl3_Task$new(
      data = train_data,
      covariates = c("A", m_names, w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  }

  # fit model on observed data
  moc_natural_fit <- lrnr_stack$train(moc_natural_task)

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    moc_natural_pred <- m_natural_fit$predict()

    # create task for post-intervention outcome regression
    if (type == "q") {
      moc_intervened_prime_task <- sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    } else if (type == "r") {
      moc_intervened_prime_task <- sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", m_names, w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    }

    # predict from trained model on counterfactual data
    moc_intervened_pred_A_prime <-
      moc_natural_fit$predict(moc_intervened_prime_task)

    # set intervention to second contrast a_star := contrast[2] and create task
    train_data_intervene[, A := contrast[2]]
    if (type == "q") {
      moc_intervened_star_task <- sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    } else if (type == "r") {
      moc_intervened_star_task <- sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", m_names, w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    }

    # predict from trained model on counterfactual data
    moc_intervened_pred_A_star <-
      moc_natural_fit$predict(moc_intervened_star_task)

    # output
    out_moc_est <- data.table::as.data.table(cbind(moc_natural_pred,
                                                   moc_intervened_pred_A_prime,
                                                   moc_intervened_pred_A_star))
    data.table::setnames(out_moc_est, c("moc_pred_A_natural",
                                        "moc_pred_A_prime",
                                        "moc_pred_A_star"))

    # output
    out <- list(
      moc_est = out_moc_est,
      moc_fit = moc_natural_fit
    )
  } else {
    # copy both training and validation data, once for each contrast
    train_data_intervene <- data.table::copy(train_data)
    valid_data_intervene <- data.table::copy(valid_data)

    # predictions on observed data (i.e., under observed treatment status)
    moc_natural_pred_train <- moc_natural_fit$predict()
    moc_natural_task_valid <- sl3::sl3_Task$new(
      data = valid_data,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )
    m_natural_pred_valid <- m_natural_fit$predict(m_natural_task_valid)

    # set intervention to first contrast a_prime := contrast[1]
    out_m_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # set intervention to first contrast a_prime := contrast[1]
      data_intervene[, A := contrast[1]]
      m_intervened_prime_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_prime <-
        m_natural_fit$predict(m_intervened_prime_task)

      # set intervention to first contrast a_star := contrast[2]
      data_intervene[, A := contrast[2]]
      m_intervened_star_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_star <- m_natural_fit$predict(m_intervened_star_task)

      # output
      out_m_est <- data.table::as.data.table(cbind(m_intervened_pred_A_prime,
                                                   m_intervened_pred_A_star))
      return(out_m_est)
    })

    # add natural treatment estimates to post-intervention predictions
    out_m_est[[1]] <- cbind(m_natural_pred_train, out_m_est[[1]])
    out_m_est[[2]] <- cbind(m_natural_pred_valid, out_m_est[[2]])
    lapply(out_m_est, function(x) {
             data.table::setnames(x, c("m_pred_A_natural",
                                       "m_pred_A_prime",
                                       "m_pred_A_star"))
    })

    # output
    out <- list(
      m_est_train = out_m_est[[1]],
      m_est_valid = out_m_est[[2]],
      m_fit = m_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit nuisance parameter u(z,a,w)
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param m_output ...
#' @param q_output ...
#' @param r_output ...
#' @param e_output ...
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_u_param <- function(data,
                        valid_data,
                        contrast,
                        lrnr_stack,
                        m_output,
                        q_output,
                        r_output,
                        e_output) {
  # extract required elements from fit likelihood components/mechanisms
  e_natural_pred <- e_output$e_est$e_pred_A_natural
  e_star_pred <- e_output$e_est$e_pred_A_star
  q_natural_pred <- q_output$est$pred_natural
  r_natural_pred <- r_output$est$pred_natural
  m_natural_pred <- m_output$m_est$m_pred_A_natural

  # construct outcome component of nuisance parameter
  u_out <- m_natural_pred * (q_natural_pred / r_natural_pred) *
      (e_star_pred / e_natural_pred)

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }


  # construct task for nuisance parameter regression
  u_data <- data[, U := u_out]
  u_task <- sl3::sl3_Task(
    data = u_data,
    covariates = c("A", "Z", w_names),
    outcome = "U"
  )

  # fit regression model and evaluate for contrast of interest
  u_natural_fit <- lrnr_stack$train(u_task)
  u_intervened_pred <- u_natural_fit$predict(u_intervened_task)


}

################################################################################

#' Fit nuisance parameter v(a,w)
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param m_output ...
#' @param q_output ...
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_v_param <- function(data,
                        valid_data,
                        contrast,
                        lrnr_stack,
                        m_output,
                        q_output) {
    # extract required elements from fit likelihood components/mechanisms
    q_natural_pred <- q_output$est$pred_natural
    m_natural_pred <- m_output$m_est$m_pred_A_natural

    # construct outcome component of nuisance parameter
    # NOTE: should include sum over Z
    v_out <- m_natural_pred * q_natural_pred

    # construct task for nuisance parameter regression
    v_data <- data[, V := v_out]
    v_task <- sl3::sl3_Task(
      data = v_data,
      covariates = c("A", w_names),
      outcome = "V"
    )

    # run regression...
}
