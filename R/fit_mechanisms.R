utils::globalVariables(c("A", ".N", "..w_names", "..phi_conditioning_nodes"))

################################################################################

#' Fit propensity score with incremental stochastic shift intervention
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param delta A \code{numeric} value indicating the degree of shift in the
#'  intervention to be used in defining the causal quantity of interest. In the
#'  case of binary interventions, this takes the form of an incremental
#'  propensity score shift, acting as a multiplier of the probability with which
#'  a given observational unit receives the intervention (EH Kennedy, 2018,
#'  JASA; <doi:10.1080/01621459.2017.1422737>).
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param shift_type A choice of the type of stochastic treatment regime to use
#'  -- either \code{"mtp"} for a modified treatment policy that shifts the
#'  center of the observed intervention distribution by the scalar \code{delta}
#'  or \code{"ipsi"} for an incremental propensity score shift that multiples
#'  the odds of receiving the intervention by the scalar \code{delta}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_g_mech <- function(data,
                       valid_data = NULL,
                       delta,
                       lrnr_stack,
                       w_names,
                       shift_type = c("ipsi", "mtp")) {
  # set argument defaults
  shift_type <- match.arg(shift_type)

  # construct task for propensity score fit
  g_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = w_names,
    outcome_type = ifelse(shift_type == "ipsi", "binomial", "continuous"),
    outcome = "A"
  )

  # fit propensity score model with natural (observed) intervention values
  g_natural_fit <- lrnr_stack$train(g_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  if (shift_type == "ipsi") {
    # set intervention A = 1
    data_intervene[, A := rep(1, .N)]
    g_intervened_task <- sl3_Task$new(
      data = data_intervene,
      covariates = w_names,
      outcome_type = "binomial",
      outcome = "A"
    )
    # get predictions from natural propensity score model for intervened data
    g_intervened_pred_A1 <- g_natural_fit$predict(g_intervened_task)

    # compute A = 0 case by symmetry
    g_intervened_pred_A0 <- 1 - g_intervened_pred_A1

    # directly computed the shifted propensity score
    g_intervened_pred_shifted_A1 <- ipsi_shift(gn_est = g_intervened_pred_A1,
                                               delta = delta)

    # compute shifted propensity score for A = 0 by symmetry
    g_intervened_pred_shifted_A0 <- 1 - g_intervened_pred_shifted_A1

    # bounding to numerical precision and for positivity considerations
    out_g_mat <- cbind(g_intervened_pred_A1,
                       g_intervened_pred_A0,
                       g_intervened_pred_shifted_A1,
                       g_intervened_pred_shifted_A0)
    out_g_est <- apply(out_g_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_g_est <- data.table::as.data.table(out_g_est)
    data.table::setnames(out_g_est, c("g_pred_A1",
                                      "g_pred_A0",
                                      "g_pred_shifted_A1",
                                      "g_pred_shifted_A0"))

    # output
    out <- list(
      g_est = out_g_est,
      g_fit = g_natural_fit
    )
  } else if (shift_type == "mtp") {
    # get predictions from natural propensity score model for observed data
    g_natural_pred <- g_natural_fit$predict()

    # create intervened data by applying modified treatment policy
    data_intervene[, A := mtp_shift(A = A, W = get(w_names), delta = delta)]
    g_shifted_task <- sl3_Task$new(
      data = data_intervene,
      covariates = w_names,
      outcome_type = "continuous",
      outcome = "A"
    )
    # get predictions from natural propensity score model for shifted data
    g_shifted_pred <- g_natural_fit$predict(g_shifted_task)

    # get natural and shifted values of A for use in numerical integration
    out_a_vals <- data.table::as.data.table(cbind(data$A, data_intervene$A))
    data.table::setnames(out_a_vals, c("a_natural", "a_shifted"))

    # construct output
    out_g_est <- data.table::as.data.table(cbind(g_natural_pred,
                                                 g_shifted_pred))
    data.table::setnames(out_g_est, c("g_natural", "g_shifted"))

    # output
    out <- list(
      a_vals = out_a_vals,
      g_est = out_g_est,
      g_fit = g_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit propensity score regression while conditioning on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | Z, W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param shift_type A choice of the type of stochastic treatment regime to use
#'  -- either \code{"mtp"} for a modified treatment policy that shifts the
#'  center of the observed intervention distribution by the scalar \code{delta}
#'  or \code{"ipsi"} for an incremental propensity score shift that multiples
#'  the odds of receiving the intervention by the scalar \code{delta}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_e_mech <- function(data,
                       valid_data = NULL,
                       lrnr_stack,
                       z_names,
                       w_names,
                       shift_type = c("ipsi", "mtp")) {
  # set argument defaults
  shift_type <- match.arg(shift_type)

  # construct task for nuisance parameter fit
  e_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c(z_names, w_names),
    outcome_type = ifelse(shift_type == "ipsi", "binomial", "continuous"),
    outcome = "A"
  )

  # fit and predict
  e_natural_fit <- lrnr_stack$train(e_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  if (shift_type == "ipsi") {
    # set intervention A = 1
    data_intervene[, A := rep(1, .N)]
    e_intervened_task <- sl3_Task$new(
      data = data_intervene,
      covariates = c(z_names, w_names),
      outcome_type = "binomial",
      outcome = "A"
    )

    # predict from trained model on counterfactual data
    e_intervened_pred_A1 <- e_natural_fit$predict(e_intervened_task)

    # get values of nuisance parameter E for A = 0 by symmetry with A = 1 case
    e_intervened_pred_A0 <- 1 - e_intervened_pred_A1

    # bounding to numerical precision and for positivity considerations
    out_e_mat <- cbind(e_intervened_pred_A1,
                       e_intervened_pred_A0)
    out_e_est <- apply(out_e_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_e_est <- data.table::as.data.table(out_e_est)
    data.table::setnames(out_e_est, c("e_pred_A1", "e_pred_A0"))

    # output
    out <- list(
      e_est = out_e_est,
      e_fit = e_natural_fit
    )
  } else if (shift_type == "mtp") {
    # predict from natural mediator-inclusive propensity score model
    e_natural_pred <- e_natural_fit$predict()

    # construct output
    out_e_est <- data.table::as.data.table(e_natural_pred)
    data.table::setnames(out_e_est, "e_natural")

    # output
    out <- list(
      e_est = out_e_est,
      e_fit = e_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit outcome regression
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param delta A \code{numeric} value indicating the degree of shift in the
#'  intervention to be used in defining the causal quantity of interest. In the
#'  case of binary interventions, this takes the form of an incremental
#'  propensity score shift, acting as a multiplier of the probability with which
#'  a given observational unit receives the intervention (EH Kennedy, 2018,
#'  JASA; <doi:10.1080/01621459.2017.1422737>), while in the case of continuous
#'  interventions, this is a modified treatment policy that shifts each value of
#'  the treatment.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression,
#'  i.e., m(A, Z, W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param shift_type A choice of the type of stochastic treatment regime to use
#'  -- either \code{"mtp"} for a modified treatment policy that shifts the
#'  center of the observed intervention distribution by the scalar \code{delta}
#'  or \code{"ipsi"} for an incremental propensity score shift that multiples
#'  the odds of receiving the intervention by the scalar \code{delta}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_m_mech <- function(data,
                       valid_data = NULL,
                       delta = 0,
                       lrnr_stack,
                       z_names,
                       w_names,
                       shift_type = c("ipsi", "mtp")) {
  # set argument defaults
  shift_type <- match.arg(shift_type)

  #  construct task for propensity score fit
  m_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c("A", z_names, w_names),
    outcome = "Y"
  )

  # fit and predict
  m_natural_fit <- lrnr_stack$train(m_natural_task)

  if (shift_type == "ipsi") {
    # use full data for counterfactual prediction if no validation data given
    if (is.null(valid_data)) {
      # copy full data
      data_intervene_A1 <- data.table::copy(data)
      data_intervene_A0 <- data.table::copy(data)
    } else {
      # copy only validation data
      data_intervene_A1 <- data.table::copy(valid_data)
      data_intervene_A0 <- data.table::copy(valid_data)
    }

    # copy data and set intervention A = 1
    data_intervene_A1[, A := rep(1, .N)]
    m_intervened_A1_task <- sl3::sl3_Task$new(
      data = data_intervene_A1,
      covariates = c("A", z_names, w_names),
      outcome = "Y"
    )
    m_intervened_pred_A1 <- m_natural_fit$predict(m_intervened_A1_task)

    # copy data and set intervention A = 0
    data_intervene_A0[, A := rep(0, .N)]
    m_intervened_A0_task <- sl3::sl3_Task$new(
      data = data_intervene_A0,
      covariates = c("A", z_names, w_names),
      outcome = "Y"
    )
    m_intervened_pred_A0 <- m_natural_fit$predict(m_intervened_A0_task)

    # output
    out_m_est <- data.table::as.data.table(cbind(m_intervened_pred_A1,
                                                 m_intervened_pred_A0))
    data.table::setnames(out_m_est, c("m_pred_A1", "m_pred_A0"))
    out <- list(
      m_pred = out_m_est,
      m_fit_sl = m_natural_fit
    )
  } else if (shift_type == "mtp") {
    # use full data for counterfactual prediction if no validation data given
    if (is.null(valid_data)) {
      # copy full data
      data_intervene <- data.table::copy(data)
    } else {
      # copy only validation data
      data_intervene <- data.table::copy(valid_data)
    }

    # get predictions from natural outcome regression model for observed data
    m_natural_pred <- m_natural_fit$predict()

    # create intervened data by applying modified treatment policy
    data_intervene[, A := mtp_shift(A = A, delta = delta)]
    m_intervened_task <- sl3::sl3_Task$new(
      data = data_intervene,
      covariates = c("A", z_names, w_names),
      outcome = "Y"
    )
    m_intervened_pred <- m_natural_fit$predict(m_intervened_task)

    # output
    out_m_est <- data.table::as.data.table(cbind(m_natural_pred,
                                                 m_intervened_pred))
    data.table::setnames(out_m_est, c("m_natural", "m_shifted"))
    out <- list(
      m_pred = out_m_est,
      m_fit_sl = m_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit intervention-specific nuisance parameter for a binary exponential tilt
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | Z, W).
#' @param m_output Object containing results from fitting the outcome
#'  regression, as produced by a call to \code{fit_m_mech}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table data.table as.data.table
#' @importFrom sl3 sl3_Task
#
fit_phi_mech_ipsi <- function(data,
                              lrnr_stack,
                              m_output,
                              w_names) {
  # difference-reduced dimension regression for phi
  m_pred_A1 <- m_output$m_pred$m_pred_A1
  m_pred_A0 <- m_output$m_pred$m_pred_A0
  m_pred_diff <- m_pred_A1 - m_pred_A0

  # construct data structure for use with task objects
  phi_data <- data.table::data.table(m_diff = m_pred_diff, data[, ..w_names])
  phi_task <- sl3::sl3_Task$new(
    data = phi_data,
    covariates = w_names,
    outcome = "m_diff",
    outcome_type = "continuous"
  )

  # fit stack of learners and predict on the same data set
  phi_fit <- lrnr_stack$train(phi_task)
  phi_est <- phi_fit$predict()
  return(phi_est)
}

################################################################################

#' Fit intervention-specific nuisance parameter for a continuous modified
#' treatment policy
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | Z, W).
#' @param m_output Object containing results from fitting the outcome
#'  regression, as produced by a call to \code{fit_m_mech}.
#' @param e_output Object containing results from fitting the propensity score
#'  regression while conditioning on mediators, as produced by a call to
#'  \code{fit_e_mech}.
#' @param g_output Object containing results from fitting the propensity score
#'  regression, as produced by a call to \code{fit_g_mech}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table data.table as.data.table
#' @importFrom sl3 sl3_Task
#
fit_phi_mech_mtp <- function(data,
                             lrnr_stack,
                             m_output,
                             e_output,
                             g_output,
                             w_names) {
  # nuisance paramter phi definition for MTPs
  m_shifted <- m_output$m_pred$m_shifted
  e_natural <- e_output$e_est$e_natural
  g_natural <- g_output$g_est$g_natural
  phi_outcome <- (g_natural / e_natural) * m_shifted

  # construct data structure for use with task objects
  phi_conditioning_nodes <- c("A", w_names)
  phi_data <- data.table::data.table(phi = phi_outcome,
                                     data[, ..phi_conditioning_nodes])
  phi_task <- sl3::sl3_Task$new(
    data = phi_data,
    covariates = phi_conditioning_nodes,
    outcome = "phi",
    outcome_type = "continuous"
  )

  # fit stack of learners and predict on the same data set
  phi_fit <- lrnr_stack$train(phi_task)
  phi_est <- phi_fit$predict()
  return(phi_est)
}
