#' Fit propensity score over given contrasts
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_g_mech <- function(data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       w_names) {
  # construct task for propensity score fit
  g_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = w_names,
    outcome = "A"
  )

  # fit propensity score model with natural (observed) intervention values
  g_natural_fit <- lrnr_stack$train(g_natural_task)
  g_natural_pred <- g_natural_fit$predict()

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  # set intervention to first contrast a_prime := contrast[1]
  data_intervene[, A := contrast[1]]
  g_intervened_task <- sl3_Task$new(
    data = data_intervene,
    covariates = w_names,
    outcome_type = "binomial",
    outcome = "A"
  )

  # get predictions from natural propensity score model for intervened data
  g_intervened_pred_A_prime <- g_natural_fit$predict(g_intervened_task)

  # compute A = a_star = contrast[2] case by symmetry
  g_intervened_pred_A_star <- 1 - g_intervened_pred_A_prime

  # bounding to numerical precision and for positivity considerations
  out_g_mat <- cbind(g_natural_pred,
                     g_intervened_pred_A_prime,
                     g_intervened_pred_A_star)
  out_g_est <- apply(out_g_mat, 2, function(x) {
                       x_precise <- bound_precision(x)
                       x_bounded <- bound_propensity(x_precise)
                       return(x_bounded)
                    })
  out_g_est <- data.table::as.data.table(out_g_est)
  data.table::setnames(out_g_est, c("g_pred_A_natural",
                                    "g_pred_A_prime",
                                    "g_pred_A_star"))

  # output
  out <- list(
    g_est = out_g_est,
    g_fit = g_natural_fit
  )
  return(out)
}

################################################################################

#' Fit propensity score conditioning on mediators over given contrasts
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | M, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_e_mech <- function(data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  # construct task for nuisance parameter fit
  e_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c(m_names, w_names),
    outcome = "A"
  )

  # fit and predict
  e_natural_fit <- lrnr_stack$train(e_natural_task)
  e_natural_pred <- e_natural_fit$predict()

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  # set intervention to first contrast a_prime := contrast[1]
  data_intervene[, A := contrast[1]]
  e_intervened_task <- sl3_Task$new(
    data = data_intervene,
    covariates = c(m_names, w_names),
    outcome_type = "binomial",
    outcome = "A"
  )

  # predict from trained model on counterfactual data
  e_intervened_pred_A_prime <- e_natural_fit$predict(e_intervened_task)

  # get values of nuisance parameter E for A = a_star = contrast[2] by symmetry
  e_intervened_pred_A_star <- 1 - e_intervened_pred_A_prime

  # bounding to numerical precision and for positivity considerations
  out_e_mat <- cbind(e_natural_pred,
                     e_intervened_pred_A_prime,
                     e_intervened_pred_A_star)
  out_e_est <- apply(out_e_mat, 2, function(x) {
                       x_precise <- bound_precision(x)
                       x_bounded <- bound_propensity(x_precise)
                       return(x_bounded)
                    })
  out_e_est <- data.table::as.data.table(out_e_est)
  data.table::setnames(out_e_est, c("e_pred_A_natural",
                                    "e_pred_A_prime",
                                    "e_pred_A_star"))

  # output
  out <- list(
    e_est = out_e_est,
    e_fit = e_natural_fit
  )
  return(out)
}

################################################################################

#' Fit outcome regression
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression,
#'  i.e., m(A, M, Z, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_m_mech <- function(data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  #  construct task for propensity score fit
  m_natural_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c("A", m_names, "Z", w_names),
    outcome = "Y"
  )

  # fit and predict
  m_natural_fit <- lrnr_stack$train(m_natural_task)
  m_natural_pred <- m_natural_fit$predict()

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  # set intervention to first contrast a_prime := contrast[1]
  data_intervene[, A := contrast[1]]
  m_intervened_task <- sl3::sl3_Task$new(
    data = data_intervene,
    covariates = c("A", m_names, "Z", w_names),
    outcome = "Y"
  )

  # predict from trained model on counterfactual data
  m_intervened_pred_A_prime <- m_natural_fit$predict(m_intervened_task)

  # get values of nuisance parameter E for A = a_star = contrast[2] by symmetry
  m_intervened_pred_A_star <- 1 - m_intervened_pred_A_prime

  # output
  out_m_est <- data.table::as.data.table(cbind(m_natural_pred,
                                               m_intervened_pred_A_prime,
                                               m_intervened_pred_A_star))
  data.table::setnames(out_m_est, c("m_pred_A_natural",
                                    "m_pred_A_prime",
                                    "m_pred_A_star"))
  out <- list(
    m_pred = out_m_est,
    m_fit_sl = m_natural_fit
  )
  return(out)
}

################################################################################

#' Fit mediator-outcome confounder score with(out) conditioning on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., q = E[z|a',W] and r = E[z|a',m,w]).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#' @param type A \code{character} vector indicating whether to condition on the
#'  mediators (M) or not. Specifically, this is an option for specifying one of
#'  two types of nuisance regressions: "r" is defined as the component that
#'  conditions on the mediators (i.e., r = E[z|a',m,w]) while "q" is defined as
#'  the component that does not (i.e., q = E[z|a',w]).
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_moc_mech <- function(data,
                         valid_data = NULL,
                         contrast,
                         lrnr_stack,
                         m_names,
                         w_names,
                         type = c("q", "r")) {
  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }

  # construct task for fitting score for mediator-outcome confounder
  if (type == "q") {
    # construct natural task for fitting
    data_natural_task <- sl3::sl3_Task$new(
      data = data_intervene,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # intervene on data
    data_intervene[, A := contrast[1]]

    # construct intervene task for prediction
    data_intervened_task <- sl3::sl3_Task$new(
      data = data_intervene,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  } else if (type == "r") {
    # construct natural task for fitting
    data_natural_task <- sl3::sl3_Task$new(
      data = data_intervene,
      covariates = c(m_names, w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # construct intervene task for prediction
    data_intervened_task <- sl3::sl3_Task$new(
      data = data_intervene,
      covariates = c("A", w_names, m_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  }

  # fitting score for mediator-outcome confounder
  natural_fit <- lrnr_stack$train(data_natural_task)
  natural_pred <- natural_fit$predict()

  # get predictions from natural propensity score model for intervened data
  intervened_pred <- natural_fit$predict(data_intervened_task)

  # bounding to numerical precision and for positivity considerations
  out_pred_mat <- cbind(natural_pred, intervened_pred)
  out_est <- apply(out_pred_mat, 2, function(x) {
                     x_precise <- bound_precision(x)
                     x_bounded <- bound_propensity(x_precise)
                     return(x_bounded)
                  })
  out_est <- data.table::as.data.table(out_est)
  data.table::setnames(out_est, c("pred_natural",
                                  "pred_intervened"))

  # output
  out <- list(
    est = out_est,
    fit = natural_fit
  )
  return(out)
}
