#' Fit propensity score for treatment contrasts
#'
#' @param train_data A \code{data.table} containing the observed data; columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{train_data}, to be used for
#'  estimation via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention "A" to be compared. The default value of \code{c(0, 1)} assumes
#'  binary intervention node "A", though support for categorical interventions
#'  is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a propensity score model,
#'  i.e., g = P(A = 1 | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_g_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       w_names) {
  # construct task for propensity score fit
  g_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = w_names,
    outcome = "A"
  )

  # fit propensity score model with natural (observed) intervention values
  # NOTE: never need the non-intervened propensity score, so don't predict...
  g_natural_fit <- lrnr_stack$train(g_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # set intervention column to the first contrast
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # set intervention to first contrast a_prime := contrast[1]
    g_intervened_task <- sl3::sl3_Task$new(
      data = train_data_intervene,
      covariates = w_names,
      outcome_type = "binomial",
      outcome = "A"
    )

    # get predictions from natural propensity score model for intervened data
    g_intervened_pred_A_prime <- g_natural_fit$predict(g_intervened_task)

    # compute A = a_star = contrast[2] case by symmetry
    g_intervened_pred_A_star <- 1 - g_intervened_pred_A_prime

    # bounding to numerical precision and for positivity considerations
    out_g_mat <- cbind(g_intervened_pred_A_prime,
                       g_intervened_pred_A_star)
    out_g_est <- apply(out_g_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_g_est <- data.table::as.data.table(out_g_est)
    data.table::setnames(out_g_est, c("g_pred_A_prime", "g_pred_A_star"))

    # output
    out <- list(
      g_est = out_g_est,
      g_fit = g_natural_fit
    )
  } else {
    # set intervention columns to first contrast for training/validation splits
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]
    valid_data_intervene <- data.table::copy(valid_data)
    valid_data_intervene[, A := contrast[1]]

    # set intervention to first contrast a_prime := contrast[1]
    out_g_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # create task to generate contrast-specific predictions
      g_intervened_task <- sl3_Task$new(
        data = data_intervene,
        covariates = w_names,
        outcome_type = "binomial",
        outcome = "A"
      )

      # get predictions from natural propensity score model for intervened data
      g_intervened_pred_A_prime <- g_natural_fit$predict(g_intervened_task)

      # compute A = a_star = contrast[2] case by symmetry
      g_intervened_pred_A_star <- 1 - g_intervened_pred_A_prime

      # bounding to numerical precision and for positivity considerations
      out_g_mat <- cbind(g_intervened_pred_A_prime,
                         g_intervened_pred_A_star)
      out_g_est <- apply(out_g_mat, 2, function(x) {
                           x_precise <- bound_precision(x)
                           x_bounded <- bound_propensity(x_precise)
                           return(x_bounded)
                        })
      out_g_est <- data.table::as.data.table(out_g_est)
      data.table::setnames(out_g_est, c("g_pred_A_prime", "g_pred_A_star"))
    })

    # output
    out <- list(
      g_est_train = out_g_est[[1]],
      g_est_valid = out_g_est[[2]],
      g_fit = g_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit propensity score conditioning on mediators over given contrasts
#'
#' @param train_data A \code{data.table} containing the observed data; columns
#'  are in the order specified by the NPSEM (Y, M, Z, A, W), with column names
#'  set appropriately based on the input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a cleverly parameterized
#'  propensity score that includes the mediators, i.e., e = P(A | M, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_e_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  # construct task for nuisance parameter fit
  e_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = c(m_names, w_names),
    outcome = "A"
  )

  # fit model on observed data
  e_natural_fit <- lrnr_stack$train(e_natural_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    e_natural_pred <- e_natural_fit$predict()

    # create task for treatment-specific propensity score for first contrast
    e_intervened_task <- sl3::sl3_Task$new(
      data = train_data_intervene,
      covariates = c(m_names, w_names),
      outcome_type = "binomial",
      outcome = "A"
    )

    # predict from trained model on counterfactual data
    e_intervened_pred_A_prime <- e_natural_fit$predict(e_intervened_task)

    # get values of nuisance parameter E for A = a_star = contrast[2] by symmetry
    e_intervened_pred_A_star <- 1 - e_intervened_pred_A_prime

    # bounding to numerical precision and for positivity considerations
    out_e_mat <- cbind(e_natural_pred,
                       e_intervened_pred_A_prime,
                       e_intervened_pred_A_star)
    out_e_est <- apply(out_e_mat, 2, function(x) {
                         x_precise <- bound_precision(x)
                         x_bounded <- bound_propensity(x_precise)
                         return(x_bounded)
                      })
    out_e_est <- data.table::as.data.table(out_e_est)
    data.table::setnames(out_e_est, c("e_pred_A_natural",
                                      "e_pred_A_prime",
                                      "e_pred_A_star"))

    # output
    out <- list(
      e_est = out_e_est,
      e_fit = e_natural_fit
    )
  } else {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]
    valid_data_intervene <- data.table::copy(valid_data)
    valid_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    e_natural_pred_train <- e_natural_fit$predict()
    e_natural_task_valid <- sl3::sl3_Task$new(
      data = valid_data,
      covariates = c(m_names, w_names),
      outcome = "A"
    )
    e_natural_pred_valid <- e_natural_fit$predict(e_natural_task_valid)

    # loop over training and validation data to get fold-specific predictions
    out_e_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # create task to generate predictions for contrast-specific predictions
      e_intervened_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c(m_names, w_names),
        outcome_type = "binomial",
        outcome = "A"
      )

      # predict from trained model on counterfactual data
      e_intervened_pred_A_prime <- e_natural_fit$predict(e_intervened_task)

      # values of nuisance parameter E for A = a_star = contrast[2] by symmetry
      e_intervened_pred_A_star <- 1 - e_intervened_pred_A_prime

      # bounding to numerical precision and for positivity considerations
      out_e_mat <- cbind(e_intervened_pred_A_prime,
                         e_intervened_pred_A_star)
      out_e_est <- apply(out_e_mat, 2, function(x) {
                           x_precise <- bound_precision(x)
                           x_bounded <- bound_propensity(x_precise)
                           return(x_bounded)
                        })
      out_e_est <- data.table::as.data.table(out_e_est)
      return(out_e_est)
    })

    # add natural treatment estimates to post-intervention predictions
    out_e_est[[1]] <- cbind(e_natural_pred_train, out_e_est[[1]])
    out_e_est[[2]] <- cbind(e_natural_pred_valid, out_e_est[[2]])
    lapply(out_e_est, function(x) {
             data.table::setnames(x, c("e_pred_A_natural",
                                       "e_pred_A_prime",
                                       "e_pred_A_star"))
    })

    # output
    out <- list(
      e_est_train = out_e_est[[1]],
      e_est_valid = out_e_est[[2]],
      e_fit = e_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit outcome regression
#'
#' @param train_data A \code{data.table} containing the observed data, with
#'  columns in the order specified by the NPSEM (Y, M, Z, A, W), with column
#'  names set based on the original input data. Such a structure is merely a
#'  convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting the outcome regression,
#'  i.e., m(A, Z, M, W).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#'
fit_m_mech <- function(train_data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       m_names,
                       w_names) {
  #  construct task for propensity score fit
  m_natural_task <- sl3::sl3_Task$new(
    data = train_data,
    covariates = c("A", m_names, "Z", w_names),
    outcome = "Y"
  )

  # fit and predict
  m_natural_fit <- lrnr_stack$train(m_natural_task)
  m_natural_pred <- m_natural_fit$predict()

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    m_natural_pred <- m_natural_fit$predict()

    # create task for post-intervention outcome regression
    m_intervened_prime_task <- sl3::sl3_Task$new(
      data = train_data_intervene,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )

    # predict from trained model on counterfactual data
    m_intervened_pred_A_prime <- m_natural_fit$predict(m_intervened_prime_task)

    # set intervention to second contrast a_star := contrast[2] and create task
    train_data_intervene[, A := contrast[2]]
    m_intervened_star_task <- sl3::sl3_Task$new(
      data = train_data_intervene,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )

    # predict from trained model on counterfactual data
    m_intervened_pred_A_star <- m_natural_fit$predict(m_intervened_star_task)

    # output
    out_m_est <- data.table::as.data.table(cbind(m_natural_pred,
                                                 m_intervened_pred_A_prime,
                                                 m_intervened_pred_A_star))
    data.table::setnames(out_m_est, c("m_pred_A_natural",
                                      "m_pred_A_prime",
                                      "m_pred_A_star"))

    # output
    out <- list(
      m_est = out_m_est,
      m_fit = m_natural_fit
    )
  } else {
    # copy both training and validation data, once for each contrast
    train_data_intervene <- data.table::copy(train_data)
    valid_data_intervene <- data.table::copy(valid_data)

    # predictions on observed data (i.e., under observed treatment status)
    m_natural_pred_train <- m_natural_fit$predict()
    m_natural_task_valid <- sl3::sl3_Task$new(
      data = valid_data,
      covariates = c("A", m_names, "Z", w_names),
      outcome = "Y"
    )
    m_natural_pred_valid <- m_natural_fit$predict(m_natural_task_valid)

    # set intervention to first contrast a_prime := contrast[1]
    out_m_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # set intervention to first contrast a_prime := contrast[1]
      data_intervene[, A := contrast[1]]
      m_intervened_prime_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_prime <-
        m_natural_fit$predict(m_intervened_prime_task)

      # set intervention to first contrast a_star := contrast[2]
      data_intervene[, A := contrast[2]]
      m_intervened_star_task <- sl3::sl3_Task$new(
        data = data_intervene,
        covariates = c("A", m_names, "Z", w_names),
        outcome = "Y"
      )

      # predict from trained model on counterfactual data
      m_intervened_pred_A_star <- m_natural_fit$predict(m_intervened_star_task)

      # output
      out_m_est <- data.table::as.data.table(cbind(m_intervened_pred_A_prime,
                                                   m_intervened_pred_A_star))
      return(out_m_est)
    })

    # add natural treatment estimates to post-intervention predictions
    out_m_est[[1]] <- cbind(m_natural_pred_train, out_m_est[[1]])
    out_m_est[[2]] <- cbind(m_natural_pred_valid, out_m_est[[2]])
    lapply(out_m_est, function(x) {
             data.table::setnames(x, c("m_pred_A_natural",
                                       "m_pred_A_prime",
                                       "m_pred_A_star"))
    })

    # output
    out <- list(
      m_est_train = out_m_est[[1]],
      m_est_valid = out_m_est[[2]],
      m_fit = m_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit mediator-outcome confounder score with(out) conditioning on mediators
#'
#' @param train_data A \code{data.table} containing observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., q = E[z|a',W] and r = E[z|a',m,w]).
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#' @param type A \code{character} vector indicating whether to condition on the
#'  mediators (M) or not. Specifically, this is an option for specifying one of
#'  two types of nuisance regressions: "r" is defined as the component that
#'  conditions on the mediators (i.e., r = E[z|a',m,w]) while "q" is defined as
#'  the component that does not (i.e., q = E[z|a',w]).
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_moc_mech <- function(train_data,
                         valid_data = NULL,
                         contrast,
                         lrnr_stack,
                         m_names,
                         w_names,
                         type = c("q", "r")) {
  # construct task for nuisance parameter fit
  if (type == "q") {
    moc_natural_task <- sl3::sl3_Task$new(
      data = train_data,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  } else if (type == "r") {
    moc_natural_task <- sl3::sl3_Task$new(
      data = train_data,
      covariates = c("A", m_names, w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )
  }

  # fit model on observed data
  moc_natural_fit <- lrnr_stack$train(moc_natural_task)

  # use full data for counterfactual prediction if no validation data given
  if (is.null(valid_data)) {
    # set intervention to first contrast a_prime := contrast[1]
    train_data_intervene <- data.table::copy(train_data)
    train_data_intervene[, A := contrast[1]]

    # predictions on observed data (i.e., under observed treatment status)
    moc_natural_pred <- m_natural_fit$predict()

    # create task for post-intervention outcome regression
    if (type == "q") {
      moc_intervened_prime_task <- sl3::sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    } else if (type == "r") {
      moc_intervened_prime_task <- sl3::sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", m_names, w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    }

    # predict from trained model on counterfactual data
    moc_intervened_pred_A_prime <-
      moc_natural_fit$predict(moc_intervened_prime_task)

    # set intervention to second contrast a_star := contrast[2] and create task
    train_data_intervene[, A := contrast[2]]
    if (type == "q") {
      moc_intervened_star_task <- sl3::sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    } else if (type == "r") {
      moc_intervened_star_task <- sl3::sl3_Task$new(
        data = train_data_intervene,
        covariates = c("A", m_names, w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    }

    # predict from trained model on counterfactual data
    moc_intervened_pred_A_star <-
      moc_natural_fit$predict(moc_intervened_star_task)

    # output
    out_moc_est <- data.table::as.data.table(cbind(moc_natural_pred,
                                                   moc_intervened_pred_A_prime,
                                                   moc_intervened_pred_A_star))
    data.table::setnames(out_moc_est, c("moc_pred_A_natural",
                                        "moc_pred_A_prime",
                                        "moc_pred_A_star"))

    # output
    out <- list(
      moc_est = out_moc_est,
      moc_fit = moc_natural_fit
    )
  } else {
    # copy both training and validation data, once for each contrast
    train_data_intervene <- data.table::copy(train_data)
    valid_data_intervene <- data.table::copy(valid_data)

    # predictions on observed data (i.e., under observed treatment status)
    moc_natural_pred_train <- moc_natural_fit$predict()

    # create task for post-intervention outcome regression
    if (type == "q") {
      moc_natural_task_valid <- sl3::sl3_Task$new(
        data = valid_data,
        covariates = c("A", w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    } else if (type == "r") {
      moc_natural_task_valid <- sl3::sl3_Task$new(
        data = valid_data,
        covariates = c("A", m_names, w_names),
        outcome_type = "binomial",
        outcome = "Z"
      )
    }

    # prediction on observed data, in validation set
    moc_natural_pred_valid <- moc_natural_fit$predict(moc_natural_task_valid)

    # set intervention to first contrast a_prime := contrast[1]
    out_moc_est <- lapply(list(train_data_intervene, valid_data_intervene),
                        function(data_intervene) {
      # intervene to set treatment to first contrast (A prime)
      data_intervene[, A := contrast[1]]

      # create task for post-intervention outcome regression
      if (type == "q") {
        moc_intervened_prime_task <- sl3::sl3_Task$new(
          data = data_intervene,
          covariates = c("A", w_names),
          outcome_type = "binomial",
          outcome = "Z"
        )
      } else if (type == "r") {
        moc_intervened_prime_task <- sl3::sl3_Task$new(
          data = data_intervene,
          covariates = c("A", m_names, w_names),
          outcome_type = "binomial",
          outcome = "Z"
        )
      }

      # predict from trained model on counterfactual data
      moc_intervened_pred_A_prime <-
        moc_natural_fit$predict(moc_intervened_prime_task)

      # set intervention to second contrast a_star := contrast[2]; create task
      data_intervene[, A := contrast[2]]
      if (type == "q") {
        moc_intervened_star_task <- sl3::sl3_Task$new(
          data = data_intervene,
          covariates = c("A", w_names),
          outcome_type = "binomial",
          outcome = "Z"
        )
      } else if (type == "r") {
        moc_intervened_star_task <- sl3::sl3_Task$new(
          data = data_intervene,
          covariates = c("A", m_names, w_names),
          outcome_type = "binomial",
          outcome = "Z"
        )
      }

      # predict from trained model on counterfactual data
      moc_intervened_pred_A_star <-
        moc_natural_fit$predict(moc_intervened_star_task)

      # output
      out_moc_est <-
        data.table::as.data.table(cbind(moc_intervened_pred_A_prime,
                                        moc_intervened_pred_A_star))
    })

    # add natural treatment estimates to post-intervention predictions
    out_moc_est[[1]] <- cbind(moc_natural_pred_train, out_moc_est[[1]])
    out_moc_est[[2]] <- cbind(moc_natural_pred_valid, out_moc_est[[2]])
    lapply(out_moc_est, function(x) {
             data.table::setnames(x, c("moc_pred_A_natural",
                                       "moc_pred_A_prime",
                                       "moc_pred_A_star"))
    })

    # output
    out <- list(
      moc_est_train = out_moc_est[[1]],
      moc_est_valid = out_moc_est[[2]],
      moc_fit = moc_natural_fit
    )
  }
  return(out)
}

################################################################################

#' Fit pseudo-outcome regression conditioning on mediator-outcome confounder
#'
#' @param train_data A \code{data.table} containing observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Not optional for this nuisance parameter.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for this nuisance
#'  parameter.
#' @param m_out ...
#' @param q_out ...
#' @param r_out ...
#' @param e_out ...
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_nuisance_u <- function(train_data,
                           valid_data,
                           lrnr_stack,
                           m_out,
                           q_out,
                           r_out,
                           e_out,
                           w_names) {
  # create pseudo-outcome based on training data
  u_pseudo_train <- m_out$m_est_train$m_pred_A_natural *
    (q_out$moc_est_train$moc_pred_A_natural /
     r_out$moc_est_train$moc_pred_A_natural) *
    (e_out$e_est_train$e_pred_A_star / e_out$e_est_train$e_pred_A_natural)

  # construct data set and training task
  u_data_train <- data.table::as.data.table(cbind(train_data[, ..w_names],
                                                  train_data$A, train_data$Z,
                                                  u_pseudo_train))
  data.table::setnames(u_data_train, c(w_names, "A", "Z", "U_pseudo"))
  u_task_train <- sl3::sl3_Task$new(
    data = u_data_train,
    covariates = c(w_names, "A", "Z"),
    outcome_type = "continuous",
    outcome = "U_pseudo"
  )

  # fit model for nuisance parameter regression on training data
  u_param_fit <- lrnr_stack$train(u_task_train)

  # now, same process but for the validation set
  u_pseudo_valid <- m_out$m_est_valid$m_pred_A_natural *
    (q_out$moc_est_valid$moc_pred_A_natural /
     r_out$moc_est_valid$moc_pred_A_natural) *
    (e_out$e_est_valid$e_pred_A_star / e_out$e_est_valid$e_pred_A_natural)

  # construct data set and validation task for prediction
  u_data_valid <- data.table::as.data.table(cbind(valid_data[, ..w_names],
                                                  valid_data$A, valid_data$Z,
                                                  u_pseudo_valid))
  data.table::setnames(u_data_valid, c(w_names, "A", "Z", "U_pseudo"))
  u_task_valid <- sl3::sl3_Task$new(
    data = u_data_valid,
    covariates = c(w_names, "A", "Z"),
    outcome_type = "continuous",
    outcome = "U_pseudo"
  )

  # predict from nuisance parameter regression model on validation data
  u_valid_pred <- u_param_fit$predict(u_task_valid)
  return(as.numeric(u_valid_pred))
}

################################################################################

#' Fit pseudo-outcome regression conditioning on treatment and baseline
#'
#' @param train_data A \code{data.table} containing observed data, with columns
#'  in the order specified by the NPSEM (Y, M, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medoutcon}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Not optional for this nuisance parameter
#' @param contrast A \code{numeric} double indicating the two values of the
#'  intervention \code{A} to be compared. The default value of \code{c(0, 1)}
#'  assumes a binary intervention node \code{A}, though support for categorical
#'  interventions is planned for future releases.
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for this nuisance
#'  parameter.
#' @param m_out ...
#' @param q_out ...
#' @param m_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (M). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medoutcon}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medoutcon}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_nuisance_v <- function(train_data,
                           valid_data,
                           contrast,
                           lrnr_stack,
                           m_out,
                           q_out,
                           m_names,
                           w_names) {
  # first, compute components of integral over mediation-outcome confounder
  v_pseudo <- lapply(as.list(unique(train_data$Z)), function(mediator_val) {
    # training data
    train_data_z_interv <- data.table::copy(train_data)
    train_data_z_interv[, Z := mediator_val]
    train_data_z_interv[, A := contrast[1]]

    # tasks for predicting from trained m and q regression models
    m_reg_train_v_subtask <- sl3::sl3_Task$new(
      data = train_data_z_interv,
      covariates = c(w_names, "A", "Z", m_names),
      outcome = "Y"
    )
    q_reg_train_v_subtask <- sl3::sl3_Task$new(
      data = train_data_z_interv,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # outcome regression after intervening on mediator-outcome confounder
    m_pred_train_z_interv <- m_out$m_fit$predict(m_reg_train_v_subtask)

    # "q" nuisance regression after intervening on mediator-outcome confounder
    q_pred_train_z_interv <- q_out$moc_fit$predict(q_reg_train_v_subtask)

    # now on validation set
    valid_data_z_interv <- data.table::copy(valid_data)
    valid_data_z_interv[, Z := mediator_val]
    valid_data_z_interv[, A := contrast[1]]

    # tasks for predicting from trained m and q regression models
    m_reg_valid_v_subtask <- sl3::sl3_Task$new(
      data = valid_data_z_interv,
      covariates = c(w_names, "A", "Z", m_names),
      outcome = "Y"
    )
    q_reg_valid_v_subtask <- sl3::sl3_Task$new(
      data = valid_data_z_interv,
      covariates = c("A", w_names),
      outcome_type = "binomial",
      outcome = "Z"
    )

    # outcome regression after intervening on mediator-outcome confounder
    m_pred_valid_z_interv <- m_out$m_fit$predict(m_reg_valid_v_subtask)

    # "q" nuisance regression after intervening on mediator-outcome confounder
    q_pred_valid_z_interv <- q_out$moc_fit$predict(q_reg_valid_v_subtask)

    # return partial pseudo-outcome for v nuisance regression
    out_train <- m_pred_train_z_interv * q_pred_train_z_interv
    out_valid <- m_pred_valid_z_interv * q_pred_valid_z_interv
    out <- list(training = out_train, validation = out_valid)
    return(out)
  })

  # compute pseudo-outcome and build regression task for training set
  v_pseudo_train <- v_pseudo[[1]]$training + v_pseudo[[2]]$training
  v_data_train <- data.table::as.data.table(cbind(train_data[, ..w_names],
                                                  train_data$A, v_pseudo_train))
  data.table::setnames(v_data_train, c(w_names, "A", "V_pseudo"))
  v_task_train <- sl3::sl3_Task$new(
    data = v_data_train,
    covariates = c(w_names, "A"),
    outcome_type = "continuous",
    outcome = "V_pseudo"
  )

  # compute pseudo-outcome and build regression task for validation set
  v_pseudo_valid <- v_pseudo[[1]]$validation + v_pseudo[[2]]$validation
  v_data_valid <- data.table::as.data.table(cbind(valid_data[, ..w_names],
                                                  valid_data$A, v_pseudo_valid))
  data.table::setnames(v_data_valid, c(w_names, "A", "V_pseudo"))
  v_task_valid <- sl3::sl3_Task$new(
    data = v_data_valid,
    covariates = c(w_names, "A"),
    outcome_type = "continuous",
    outcome = "V_pseudo"
  )

  # fit regression model for v on training task, get predictions on validation
  v_param_fit <- lrnr_stack$train(v_task_train)
  v_valid_pred <- v_param_fit$predict(v_task_valid)

  # return prediction on validation set
  return(list(v_pred = as.numeric(v_valid_pred),
              v_pseudo = as.numeric(v_pseudo_valid)))
}
